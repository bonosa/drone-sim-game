<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>PAC-MAN ‚Äî AI AGENTS EDITION</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{touch-action:manipulation;-ms-touch-action:manipulation}
body{background:#0a0a12;display:flex;flex-direction:column;align-items:center;min-height:100vh;min-height:100dvh;font-family:'Press Start 2P',monospace;overflow-x:hidden;padding:4px 0}
#header{display:flex;justify-content:space-between;width:min(560px,96vw);padding:4px 0;color:#fff;font-size:min(11px,2.5vw)}
#header .score-value{margin-top:3px}.high-score{text-align:center}.lives-display{text-align:right}
#game-container{position:relative;border:2px solid #ff2266;border-radius:4px;box-shadow:0 0 20px rgba(255,34,102,.25);width:min(560px,96vw);max-height:60vh;max-height:60dvh;aspect-ratio:28/31}
canvas{display:block;width:100%;height:100%}
#ai-panel{width:min(560px,96vw);margin-top:4px;background:#0e0e1a;border:2px solid #333;border-radius:6px;padding:6px 8px;font-size:min(8px,1.8vw);color:#888;display:none}
#ai-panel.active{display:block}.ai-title{color:#ff2266;font-size:min(10px,2.2vw);margin-bottom:4px}
.ai-row{display:flex;justify-content:space-between;margin-bottom:5px}.ai-label{color:#666}.ai-value{color:#0f0}
.ai-value.danger{color:#f44}.ai-value.warn{color:#fa0}
#ghost-roles{margin-top:8px;padding-top:8px;border-top:1px solid #222;display:grid;grid-template-columns:1fr 1fr;gap:4px}
.ghost-role-item{display:flex;align-items:center;gap:6px}.ghost-dot{width:8px;height:8px;border-radius:50%}.ghost-role-text{color:#aaa;font-size:7px}
#claude-thought{margin-top:8px;padding-top:8px;border-top:1px solid #222;color:#0ff;line-height:1.6;min-height:20px;font-size:7px}
#overlay{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,.85);z-index:10}
#overlay.hidden{display:none}
#overlay h1{color:#ff2266;font-size:min(22px,5vw);margin-bottom:6px;text-shadow:0 0 20px rgba(255,34,102,.6)}
#overlay .subtitle{color:#0ff;font-size:min(10px,2.5vw);margin-bottom:12px;letter-spacing:2px}
#overlay p{color:#aaa;font-size:min(9px,2.2vw);margin-bottom:4px;line-height:1.8}
#overlay .start-hint{color:#FFD700;font-size:min(14px,3.5vw);margin-top:16px;animation:blink 1s step-end infinite;padding:10px 16px;border:2px solid #FFD700;border-radius:8px;cursor:pointer}
#ready-text{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#FFD700;font-family:'Press Start 2P',monospace;font-size:16px;z-index:5;display:none}
#difficulty-badge{position:absolute;top:8px;right:8px;font-size:7px;color:#000;padding:3px 8px;border-radius:3px;z-index:5;display:none}
#touch-controls{display:none;justify-content:center;margin-top:4px}
.d-pad{display:grid;grid-template-areas:". up ." "left . right" ". down .";gap:4px}
.d-pad button{width:60px;height:60px;background:#1a1a2e;border:2px solid #ff2266;border-radius:10px;color:#FFD700;font-size:22px;cursor:pointer;display:flex;align-items:center;justify-content:center;user-select:none;-webkit-tap-highlight-color:transparent;touch-action:manipulation;-webkit-user-select:none}
.d-pad button:active{background:#ff2266;transform:scale(0.92)}
.d-pad .up{grid-area:up}.d-pad .down{grid-area:down}.d-pad .left{grid-area:left}.d-pad .right{grid-area:right}
@media(pointer:coarse){#touch-controls{display:flex}#ai-panel{display:none!important}}
@keyframes blink{50%{opacity:0}}
#diff-select{margin-top:8px;text-align:center}
.diff-buttons{display:flex;gap:8px;justify-content:center;margin-top:10px}
.diff-btn{font-family:'Press Start 2P',monospace;font-size:min(9px,2.2vw);padding:8px 12px;border:2px solid #444;border-radius:6px;background:#1a1a2e;color:#888;cursor:pointer;transition:all .15s;touch-action:manipulation}
.diff-btn:hover{border-color:#ff2266;color:#fff}
#btn-easy.selected{border-color:#0f0;background:#0a3a0a;color:#0f0}
#btn-medium.selected{border-color:#FFD700;background:#3a3000;color:#FFD700}
#btn-hard.selected{border-color:#f44;background:#3a0a0a;color:#f44}
.diff-desc{color:#666;font-size:7px;margin-top:10px;line-height:1.6}
</style>
</head>
<body>
<div id="header">
  <div><div>1UP</div><div class="score-value" id="score">0</div></div>
  <div class="high-score"><div>HIGH SCORE</div><div class="score-value" id="high-score">0</div></div>
  <div class="lives-display"><div>LIVES</div><div class="score-value" id="lives-display"></div></div>
</div>
<div id="game-container">
  <canvas id="game"></canvas>
  <div id="overlay">
    <h1>PAC-MAN</h1>
    <div class="subtitle">‚ö° AI AGENTS EDITION ‚ö°</div>
    <p>Q-Learning ghosts that evolve over time</p>
    <p>A* with directional cost weighting</p>
    <p>Cooperative tactics &amp; pattern learning</p>
    <div id="diff-select">
      <p style="margin-top:18px;color:#fff;">SELECT DIFFICULTY</p>
      <div class="diff-buttons">
        <button class="diff-btn selected" data-diff="easy" id="btn-easy">EASY</button>
        <button class="diff-btn" data-diff="medium" id="btn-medium">MEDIUM</button>
        <button class="diff-btn" data-diff="hard" id="btn-hard">HARD</button>
      </div>
      <div id="diff-desc" class="diff-desc">Slow ghosts ¬∑ No A* ¬∑ Long power-ups ¬∑ 5 lives</div>
    </div>
    <div class="start-hint" id="start-watch" style="margin-top:12px;border-color:#0ff;color:#0ff">ü§ñ WATCH AI</div>
  </div>
  <div id="ready-text">READY!</div>
  <div id="difficulty-badge">EASY</div>
  <div id="ai-mode-badge" style="position:absolute;top:8px;left:8px;font-size:7px;color:#0ff;padding:3px 8px;border-radius:3px;z-index:5;display:none;background:#003;border:1px solid #0ff;font-family:'Press Start 2P',monospace;animation:blink 1.5s step-end infinite">ü§ñ AI</div>
</div>
<div id="ai-panel">
  <div class="ai-title">üß† AI AGENT STATUS</div>
  <div class="ai-row"><span class="ai-label">DIFFICULTY</span><span class="ai-value" id="ai-diff">‚Äî</span></div>
  <div class="ai-row"><span class="ai-label">PATTERN MEMORY</span><span class="ai-value" id="ai-patterns">0</span></div>
  <div class="ai-row"><span class="ai-label">A* MODE</span><span class="ai-value" id="ai-astar">OFF</span></div>
  <div class="ai-row"><span class="ai-label">Q-LEARNING</span><span class="ai-value" id="ai-qlearn">‚Äî</span></div>
  <div id="ghost-roles">
    <div class="ghost-role-item"><div class="ghost-dot" style="background:#FF0000"></div><span class="ghost-role-text" id="role-blinky">BLINKY: ‚Äî</span></div>
    <div class="ghost-role-item"><div class="ghost-dot" style="background:#FFB8FF"></div><span class="ghost-role-text" id="role-pinky">PINKY: ‚Äî</span></div>
    <div class="ghost-role-item"><div class="ghost-dot" style="background:#00FFFF"></div><span class="ghost-role-text" id="role-inky">INKY: ‚Äî</span></div>
    <div class="ghost-role-item"><div class="ghost-dot" style="background:#FFB852"></div><span class="ghost-role-text" id="role-clyde">CLYDE: ‚Äî</span></div>
  </div>
  <div id="claude-thought">Agents initializing...</div>
</div>
<div id="touch-controls">
  <div class="d-pad">
    <button class="up" id="btn-up">‚ñ≤</button>
    <button class="left" id="btn-left">‚óÄ</button>
    <button class="right" id="btn-right">‚ñ∂</button>
    <button class="down" id="btn-down">‚ñº</button>
  </div>
</div>
<script>
// ==== PREVENT iOS ZOOM ====
// Block pinch zoom
document.addEventListener('gesturestart',e=>e.preventDefault(),{passive:false});
document.addEventListener('gesturechange',e=>e.preventDefault(),{passive:false});
document.addEventListener('gestureend',e=>e.preventDefault(),{passive:false});
// Block double-tap zoom by preventing rapid touchend
let lastTouch=0;
document.addEventListener('touchend',e=>{
  const now=Date.now();
  if(now-lastTouch<300)e.preventDefault();
  lastTouch=now;
},{passive:false});
// Block multi-finger zoom
document.addEventListener('touchstart',e=>{
  if(e.touches.length>1)e.preventDefault();
},{passive:false});

// ==== SOUND ====
let audioCtx;
function ensureAudio(){if(!audioCtx)audioCtx=new(window.AudioContext||window.webkitAudioContext)();if(audioCtx.state==='suspended')audioCtx.resume();}
function tone(f,dur,type='square',vol=0.1){if(!audioCtx)return;const o=audioCtx.createOscillator(),g=audioCtx.createGain();o.connect(g);g.connect(audioCtx.destination);o.type=type;o.frequency.setValueAtTime(f,audioCtx.currentTime);g.gain.setValueAtTime(vol,audioCtx.currentTime);g.gain.exponentialRampToValueAtTime(.001,audioCtx.currentTime+dur);o.start();o.stop(audioCtx.currentTime+dur);}
let chompFlip=0;
function sndChomp(){chompFlip^=1;tone(chompFlip?261:293,.05,'sawtooth',.08);}
function sndPower(){[400,500,600,800].forEach((f,i)=>setTimeout(()=>tone(f,.1,'sine',.15),i*60));}
function sndEatGhost(){[200,400,600,800,1000].forEach((f,i)=>setTimeout(()=>tone(f,.04,'triangle',.12),i*30));}
function sndDeath(){for(let i=0;i<8;i++)setTimeout(()=>tone(700-i*60,.1,'sawtooth',.1),i*90);}
function sndStart(){[523,659,784,1047].forEach((f,i)=>setTimeout(()=>tone(f,.12,'sine',.12),i*110));}
function sndWin(){[784,988,1175,1319,1568].forEach((f,i)=>setTimeout(()=>tone(f,.12,'sine',.15),i*90));}

// ==== MAP ====
const T=20,C=28,R=31,DIRS=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];
const canvas=document.getElementById('game'),ctx=canvas.getContext('2d');
canvas.width=C*T;canvas.height=R*T;
const MS=["1111111111111111111111111111","1222222222222112222222222221","1211112111112112111121111121","1311112111112112111121111131","1211112111112112111121111121","1222222222222222222222222221","1211112112111111211211112121","1211112112111111211211112121","1222222112222112222112222221","1111112111110110111121111121","0000012111110110111121000000","0000012110000000011121000000","0000012110111411011121000000","1111112110100001011121111111","5000002000100001000002000005","1111112110100001011121111111","0000012110111111011121000000","0000012110000000011121000000","0000012110111111011121000000","1111112110111111011121111111","1222222222222112222222222221","1211112111112112111121111121","1211112111112112111121111121","1322112222222002222222112231","1112112112111111211211211121","1112112112111111211211211121","1222222112222112222112222221","1211111111112112111111111121","1211111111112112111111111121","1222222222222222222222222221","1111111111111111111111111111"];
let map=[],totalDots=0,dotsEaten=0;
function initMap(){map=[];totalDots=0;dotsEaten=0;for(let r=0;r<R;r++){map[r]=[];for(let c=0;c<C;c++){map[r][c]=+MS[r][c];if(map[r][c]===2||map[r][c]===3)totalDots++;}}}
function ok(x,y){if(x<0||x>=C)return true;if(y<0||y>=R)return false;return map[y][x]!==1;}
function gok(x,y,m,e){if(x<0||x>=C)return true;if(y<0||y>=R)return false;if(map[y][x]===1)return false;if(map[y][x]===4&&m!=='house'&&!e)return false;return true;}
function wx(x){return x<0?C-1:x>=C?0:x;}
function exits(x,y){let n=0;for(const d of DIRS){let nx=x+d.x,ny=y+d.y;if(nx<0)nx=C-1;if(nx>=C)nx=0;if(ny>=0&&ny<R&&map[ny][nx]!==1&&map[ny][nx]!==4)n++;}return n;}

// ==== STATE ====
let score=0,hi=+(localStorage.getItem('pac4_hi')||'0'),lives=5,level=1;
let gs='menu',af=0,frightT=0,readyT=0,scIdx=0,scT=0,isScat=true,selDiff='easy';
document.getElementById('high-score').textContent=hi;

// ==== PRESETS ====
const PRE={
  easy:{lives:5,gSpd:.11,frightD:500,astar:true,coop:false,pred:0,qEps:.35,startLvl:.5,desc:'A* ghosts ¬∑ No coop ¬∑ Long power-ups ¬∑ 5 lives'},
  medium:{lives:3,gSpd:.12,frightD:350,astar:true,coop:true,pred:3,qEps:.15,startLvl:1.2,desc:'A* + Coop tactics ¬∑ Pattern prediction ¬∑ 3 lives'},
  hard:{lives:2,gSpd:.14,frightD:200,astar:true,coop:true,pred:5,qEps:.05,startLvl:2.2,desc:'Fast A* ¬∑ Full coop ¬∑ Q-exploit ¬∑ 2 lives'}
};

// ==== DIFFICULTY ====
const diff={level:1,gSpd:.10,frightD:600,astar:false,coop:false,pred:0,deaths:0,gKills:0,dpl:[],surv:0,
  upd(){
    const p=PRE[selDiff]||PRE.easy;
    // Adaptive difficulty ONLY scales within the preset's bounds
    const kr=this.gKills/Math.max(1,this.deaths+this.gKills);
    const avg=this.dpl.length?this.dpl.reduce((a,b)=>a+b)/this.dpl.length:0;
    const dr=avg/Math.max(totalDots,1);
    const perf=kr*.3+dr*.5+Math.min(this.surv/3000,1)*.2;
    // Level can only go up to the NEXT preset's threshold, not beyond
    const maxLevel=selDiff==='easy'?0.99:selDiff==='medium'?1.99:3.0;
    this.level=Math.max(p.startLvl,Math.min(maxLevel,p.startLvl+perf*0.5));
    // Speed scales slightly within preset, never beyond preset base
    this.gSpd=p.gSpd+perf*0.01;
    // These features ONLY activate if the preset says so
    this.frightD=p.frightD;
    this.astar=p.astar;
    this.coop=p.coop;
    this.pred=p.pred;
    // Badge always matches selected preset
    const b=document.getElementById('difficulty-badge');
    if(selDiff==='easy'){b.textContent='EASY';b.style.background='#0f0';b.style.color='#000';}
    else if(selDiff==='medium'){b.textContent='MEDIUM';b.style.background='#FFD700';b.style.color='#000';}
    else{b.textContent='HARD';b.style.background='#f44';b.style.color='#fff';}
  },
  die(){this.deaths++;this.dpl.push(dotsEaten);if(this.dpl.length>5)this.dpl.shift();this.upd();},
  kill(){this.gKills++;this.upd();},
  reset(){this.deaths=0;this.gKills=0;this.dpl=[];this.surv=0;}
};

// ==== A* ====
function astar(sx,sy,gx,gy,cf){
  const key=(x,y)=>`${x},${y}`,open=[{x:sx,y:sy,g:0,f:0,p:null}],cl=new Set(),gs2={};gs2[key(sx,sy)]=0;let it=0;
  while(open.length&&it++<400){let bi=0;for(let i=1;i<open.length;i++)if(open[i].f<open[bi].f)bi=i;const c=open.splice(bi,1)[0];
  if(c.x===gx&&c.y===gy){let n=c;while(n.p&&n.p.p)n=n.p;return n.p?{x:n.x-sx,y:n.y-sy}:{x:0,y:0};}
  cl.add(key(c.x,c.y));for(const d of DIRS){let nx=c.x+d.x,ny=c.y+d.y;if(nx<0)nx=C-1;if(nx>=C)nx=0;if(ny<0||ny>=R||map[ny][nx]===1)continue;const k=key(nx,ny);if(cl.has(k))continue;const mc=cf?cf(nx,ny):1;const tg=c.g+mc;if(gs2[k]!==undefined&&tg>=gs2[k])continue;gs2[k]=tg;open.push({x:nx,y:ny,g:tg,f:tg+Math.abs(nx-gx)+Math.abs(ny-gy),p:c});}}
  return null;
}

// ==== PATTERN MEMORY ====
const pm={moves:[],hm:{},tp:{},pt:null,
  rec(x,y,d){this.moves.push({x,y,d:{...d}});if(this.moves.length>200)this.moves.shift();const k=`${x},${y}`;this.hm[k]=(this.hm[k]||0)+1;if(exits(x,y)>=3&&(d.x||d.y)){if(!this.tp[k])this.tp[k]=[];this.tp[k].push({dx:d.x,dy:d.y});if(this.tp[k].length>12)this.tp[k].shift();}},
  pred(px,py,pd,steps){let x=px,y=py,d={...pd};for(let s=0;s<steps;s++){const k=`${x},${y}`;if(this.tp[k]&&this.tp[k].length>2){const f={};this.tp[k].forEach(dd=>{const dk=`${dd.dx},${dd.dy}`;f[dk]=(f[dk]||0)+1;});let bd=d,bc=0;for(const[dk,c2]of Object.entries(f)){if(c2>bc){const[dx,dy]=dk.split(',').map(Number);bc=c2;bd={x:dx,y:dy};}}d=bd;}let nx=x+d.x,ny=y+d.y;if(nx<0)nx=C-1;if(nx>=C)nx=0;if(ny>=0&&ny<R&&map[ny][nx]!==1){x=nx;y=ny;}else break;}this.pt={x,y};return{x,y};},
  hot(){let bk=null,bv=0;for(const[k,v]of Object.entries(this.hm))if(v>bv){bv=v;bk=k;}if(!bk)return null;const[x,y]=bk.split(',').map(Number);return{x,y};},
  reset(){this.moves=[];this.hm={};this.tp={};this.pt=null;}
};

// ==== Q-LEARNER ====
class QL{
  constructor(n){this.n=n;this.a=.15;this.g=.9;this.eps=.2;this.me=.05;this.dr=.9995;this.qt={};this.ls=null;this.la=null;this.nu=0;this.load();}
  enc(gh,p){const dx=Math.max(-7,Math.min(7,p.x-gh.x)),dy=Math.max(-7,Math.min(7,p.y-gh.y));let w=0;for(let i=0;i<4;i++){const nx=wx(gh.x+DIRS[i].x),ny=gh.y+DIRS[i].y;if(ny<0||ny>=R||map[ny][nx]===1)w|=1<<i;}return`${Math.floor(dx/3)},${Math.floor(dy/3)},${p.dir.x===1?1:p.dir.x===-1?3:p.dir.y===1?2:0},${w},${gh.fr?1:0}`;}
  gq(s,a){return this.qt[`${s}|${a}`]||0;}sq(s,a,v){this.qt[`${s}|${a}`]=v;}
  pick(s,va){if(!va.length)return 0;if(Math.random()<this.eps)return va[Math.floor(Math.random()*va.length)];let bq=-1e9,ba=va[0];for(const a2 of va){const q=this.gq(s,a2);if(q>bq){bq=q;ba=a2;}}return ba;}
  upd(r,ns,va){if(!this.ls)return;const oq=this.gq(this.ls,this.la);let mq=-1e9;for(const a2 of(va.length?va:[0,1,2,3]))mq=Math.max(mq,this.gq(ns,a2));if(mq===-1e9)mq=0;this.sq(this.ls,this.la,oq+this.a*(r+this.g*mq-oq));this.nu++;this.eps=Math.max(this.me,this.eps*this.dr);}
  term(r){if(!this.ls)return;this.sq(this.ls,this.la,this.gq(this.ls,this.la)+this.a*(r-this.gq(this.ls,this.la)));this.nu++;this.ls=null;this.la=null;}
  save(){try{const e=Object.entries(this.qt).sort((a,b)=>Math.abs(b[1])-Math.abs(a[1])).slice(0,2000);localStorage.setItem(`pq4_${this.n}`,JSON.stringify({q:Object.fromEntries(e),e:this.eps,n:this.nu}));}catch(e){}}
  load(){try{const r=localStorage.getItem(`pq4_${this.n}`);if(r){const d=JSON.parse(r);this.qt=d.q||{};this.eps=d.e||.2;this.nu=d.n||0;}}catch(e){}}
  stats(){return{st:Object.keys(this.qt).length,nu:this.nu};}
}

// ==== PAC-MAN: CONTINUOUS MOVEMENT ====
// Like real Pac-Man: always moving. Press a direction to steer.
// Buffered input (15 frames) so you never miss a turn.
const PAC_TICK=8; // frames per tile ‚Äî pac moves ~7.5 tiles/sec at 60fps
let pac={x:14,y:23,dir:{x:0,y:0},want:{x:-1,y:0},buf:null,bufT:0,tick:0,ma:0,mo:true};
function resetPac(){pac={x:14,y:23,dir:{x:0,y:0},want:{x:-1,y:0},buf:null,bufT:0,tick:0,ma:0,mo:true};}
function pacInput(d){
  // Can we turn immediately?
  const nx=wx(pac.x+d.x),ny=pac.y+d.y;
  if(ok(nx,ny)&&(ny<0||ny>=R||map[ny][nx]!==4)){pac.want={...d};pac.buf=null;pac.bufT=0;}
  else{pac.buf={...d};pac.bufT=15;} // buffer for 15 frames
}
function pacStep(){
  // Try buffered input every frame
  if(pac.buf&&pac.bufT>0){
    pac.bufT--;
    const nx=wx(pac.x+pac.buf.x),ny=pac.y+pac.buf.y;
    if(ok(nx,ny)&&(ny<0||ny>=R||map[ny][nx]!==4)){pac.want={...pac.buf};pac.buf=null;pac.bufT=0;}
  }
  if(pac.bufT<=0)pac.buf=null;
  pac.tick++;if(pac.tick<PAC_TICK)return false;pac.tick=0;
  // Try wanted direction
  let nx=wx(pac.x+pac.want.x),ny=pac.y+pac.want.y;
  if(ok(nx,ny)&&(ny<0||ny>=R||map[ny][nx]!==4))pac.dir={...pac.want};
  // Move in current direction
  nx=wx(pac.x+pac.dir.x);ny=pac.y+pac.dir.y;
  if(ok(nx,ny)&&(ny<0||ny>=R||map[ny][nx]!==4)){pac.x=nx;pac.y=ny;return true;}
  return false;
}

// ==== PAC-MAN AI AUTOPILOT ====
// BFS to find nearest pellets, ghost danger avoidance, power pellet strategy
let aiMode=false; // false=human plays, true=AI plays

const pacAI={
  // BFS: find path to nearest target tile, avoiding ghost danger zones
  // avoidFn: optional function(x,y) returning true for tiles to treat as walls
  bfs(startX, startY, targetFn, dangerMap, avoidFn){
    const visited=new Set();
    const queue=[{x:startX,y:startY,firstDir:null,dist:0}];
    visited.add(`${startX},${startY}`);
    while(queue.length>0){
      const cur=queue.shift();
      // Check if this tile is a target
      if(cur.dist>0 && targetFn(cur.x,cur.y)){
        return cur.firstDir; // return the first step direction
      }
      if(cur.dist>40)continue; // don't search too far
      for(const d of DIRS){
        const nx=wx(cur.x+d.x),ny=cur.y+d.y;
        if(ny<0||ny>=R)continue;
        if(!ok(nx,ny))continue;
        if(map[ny]&&map[ny][nx]===4)continue; // skip ghost gate
        if(avoidFn&&avoidFn(nx,ny))continue; // skip avoided tiles
        const k=`${nx},${ny}`;
        if(visited.has(k))continue;
        // Skip tiles near ghosts (danger zones) unless we're frightening them
        const danger=dangerMap?dangerMap[k]||0:0;
        if(danger>0 && cur.dist<danger)continue; // too close to ghost
        visited.add(k);
        queue.push({x:nx,y:ny,firstDir:cur.firstDir||{...d},dist:cur.dist+1});
      }
    }
    return null;
  },

  // Build danger map: tiles near non-frightened ghosts are dangerous
  buildDangerMap(){
    const dm={};
    ghosts.forEach(g=>{
      if(g.mode==='house'||g.eat)return;
      if(g.fr)return; // frightened ghosts are targets, not threats
      // Mark tiles within radius as dangerous
      const radius=4;
      for(let dy=-radius;dy<=radius;dy++){
        for(let dx=-radius;dx<=radius;dx++){
          const dist=Math.abs(dx)+Math.abs(dy);
          if(dist>radius)continue;
          const nx=wx(g.x+dx),ny=g.y+dy;
          if(ny>=0&&ny<R){
            const k=`${nx},${ny}`;
            dm[k]=Math.max(dm[k]||0, radius-dist+1);
          }
        }
      }
    });
    return dm;
  },

  // Decide Pac-Man's next direction
  think(){
    const dm=this.buildDangerMap();
    const activeGhosts=ghosts.filter(g=>g.mode!=='house'&&!g.eat);
    const dangerousGhosts=activeGhosts.filter(g=>!g.fr);
    const blueGhosts=activeGhosts.filter(g=>g.fr);
    const anyBlue=blueGhosts.length>0;
    const nearestDangerDist=dangerousGhosts.length?Math.min(...dangerousGhosts.map(g=>Math.abs(g.x-pac.x)+Math.abs(g.y-pac.y))):99;

    // === POWER PELLET TRAP STRATEGY ===
    // Find nearest power pellet and distance to it
    let nearestPelletDist=99, nearestPelletDir=null;
    for(let r=0;r<R;r++)for(let c=0;c<C;c++){
      if(map[r]&&map[r][c]===3){
        const d2=Math.abs(c-pac.x)+Math.abs(r-pac.y);
        if(d2<nearestPelletDist){nearestPelletDist=d2;nearestPelletDir=this.bfs(pac.x,pac.y,(x,y)=>x===c&&y===r,null);}
      }
    }

    // Treat power pellet tiles as WALLS during pathfinding (so AI never steps on them accidentally)
    const avoidPP=(x,y)=>map[y]&&map[y][x]===3;
    // Any regular dots left?
    let hasRegDots=false;
    for(let r=0;r<R&&!hasRegDots;r++)for(let c=0;c<C&&!hasRegDots;c++)if(map[r][c]===2)hasRegDots=true;

    // Priority 1: Hunt frightened ghosts ‚Äî route AROUND power pellets
    if(anyBlue && frightT>40){
      const huntDir=this.bfs(pac.x,pac.y,(x,y)=>{
        return blueGhosts.some(g=>g.x===x&&g.y===y);
      }, null, avoidPP);
      if(huntDir){
        if(frightT>200 && blueGhosts.length>0){
          const nearestBlue=Math.min(...blueGhosts.map(g=>Math.abs(g.x-pac.x)+Math.abs(g.y-pac.y)));
          if(nearestBlue>6 && af%3===0)return null;
        }
        return huntDir;
      }
    }

    // Priority 2: POWER PELLET TRAP ‚Äî lure ghosts then strike
    if(nearestPelletDist<=3 && !anyBlue && hasRegDots){
      if(nearestDangerDist<=4){
        return nearestPelletDir; // SPRING THE TRAP
      } else if(nearestDangerDist<=15){
        // Wait ‚Äî eat nearby regular dots, routing AROUND power pellets
        const waitDir=this.bfs(pac.x,pac.y,(x,y)=>map[y]&&map[y][x]===2, dm, avoidPP);
        if(waitDir)return waitDir;
        return null; // stand still
      }
    }

    // Priority 3: Emergency ‚Äî ghost very close, rush to power pellet
    if(nearestDangerDist<=4 && nearestPelletDir){
      return nearestPelletDir;
    }

    // Priority 4: Eat regular dots, routing AROUND power pellets
    const dotDir=this.bfs(pac.x,pac.y,(x,y)=>map[y]&&map[y][x]===2, dm, avoidPP);
    if(dotDir)return dotDir;

    // Priority 5: No safe path ‚Äî drop danger avoidance, still avoid pellets
    const anyDotDir=this.bfs(pac.x,pac.y,(x,y)=>map[y]&&map[y][x]===2, null, avoidPP);
    if(anyDotDir)return anyDotDir;

    // Priority 6: Only power pellets remain ‚Äî eat them
    const ppDir=this.bfs(pac.x,pac.y,(x,y)=>map[y]&&map[y][x]===3, dm);
    if(ppDir)return ppDir;
    const ppDir2=this.bfs(pac.x,pac.y,(x,y)=>map[y]&&map[y][x]===3, null);
    if(ppDir2)return ppDir2;

    // Fallback: move in any valid direction
    for(const d of DIRS){
      const nx=wx(pac.x+d.x),ny=pac.y+d.y;
      if(ok(nx,ny)&&(ny<0||ny>=R||map[ny][nx]!==4))return d;
    }
    return{x:0,y:0};
  }
};

// ==== GHOST AGENT ====
const GN=['blinky','pinky','inky','clyde'],GC=['#FF0000','#FFB8FF','#00FFFF','#FFB852'];
const GST=[{x:14,y:11},{x:14,y:14},{x:12,y:14},{x:16,y:14}];
const GSCAT=[{x:25,y:0},{x:2,y:0},{x:27,y:30},{x:0,y:30}];
class Ghost{
  constructor(nm,i){this.nm=nm;this.i=i;this.col=GC[i];this.sx=GST[i].x;this.sy=GST[i].y;this.scat=GSCAT[i];this.pers=['approach_behind','approach_ahead','direct','wander_biased'][i];this.ql=new QL(nm);this.reset();}
  reset(){this.x=this.sx;this.y=this.sy;this.dir=this.i===0?{x:-1,y:0}:{x:0,y:0};this.mp=0;this.spd=diff.gSpd;this.mode=this.i===0?(isScat?'scatter':'chase'):'house';this.fr=false;this.eat=false;
    // Release timers: quick release on all difficulties
    const relMult=selDiff==='hard'?20:selDiff==='medium'?30:40;
    this.rt=this.i*relMult;
    this.role=null;this.pdist=0;}
  costFn(px,py,pd){
    const mo=new Set(),fr=new Set(),bh=new Set();
    for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){if(!dx&&!dy)continue;mo.add(`${wx(px+dx)},${py+dy}`);}
    for(let i=1;i<=2;i++){fr.add(`${wx(px+pd.x*i)},${py+pd.y*i}`);bh.add(`${wx(px-pd.x*i)},${py-pd.y*i}`);}
    switch(this.pers){
      case 'approach_behind':return(nx,ny)=>{const k=`${nx},${ny}`;return fr.has(k)?50:mo.has(k)?25:1;};
      case 'approach_ahead':return(nx,ny)=>{const k=`${nx},${ny}`;return bh.has(k)?50:mo.has(k)?25:1;};
      case 'wander_biased':return(nx,ny)=>{const dx2=Math.abs(nx-px),dy2=Math.abs(ny-py);return Math.max(1,dx2*dx2+dy2*dy2);};
      default:return()=>1;
    }
  }
  target(p){
    if(this.eat)return{x:14,y:14};
    if(this.fr)return{x:Math.max(0,Math.min(C-1,this.x+(this.x-p.x)*2)),y:Math.max(0,Math.min(R-1,this.y+(this.y-p.y)*2))};
    if(this.mode==='scatter')return this.scat;
    if(this.role&&diff.coop){const pr=pm.pred(p.x,p.y,p.dir,diff.pred),hz=pm.hot();switch(this.role){case 'chase':return{x:p.x,y:p.y};case 'intercept':return pr;case 'patrol':return hz||{x:p.x,y:p.y};case 'flank':return{x:Math.max(0,Math.min(C-1,p.x*2-this.x)),y:Math.max(0,Math.min(R-1,p.y*2-this.y))};case 'guard_pellet':let n=null,nd=1e9;for(let r=0;r<R;r++)for(let c=0;c<C;c++)if(map[r][c]===3){const d2=Math.abs(c-p.x)+Math.abs(r-p.y);if(d2<nd){nd=d2;n={x:c,y:r};}}return n||{x:p.x,y:p.y};}}
    const pr=diff.pred>0?pm.pred(p.x,p.y,p.dir,diff.pred):null;
    switch(this.i){case 0:return pr||{x:p.x,y:p.y};case 1:return{x:p.x+p.dir.x*4,y:p.y+p.dir.y*4};case 2:const b=ghosts[0];const ax=p.x+p.dir.x*2,ay=p.y+p.dir.y*2;return{x:ax+(ax-b.x),y:ay+(ay-b.y)};case 3:return Math.abs(this.x-p.x)+Math.abs(this.y-p.y)>8?{x:p.x,y:p.y}:this.scat;default:return{x:p.x,y:p.y};}
  }
  act(p){
    const opp={x:-this.dir.x,y:-this.dir.y};const va=[];
    // At house exit or just released: allow ALL directions (no opposite exclusion)
    const atExit=(this.x===14&&this.y===11)||(this.x===13&&this.y===11)||(this.x===15&&this.y===11);
    for(let i=0;i<4;i++){const d=DIRS[i];if(!atExit&&d.x===opp.x&&d.y===opp.y)continue;if(gok(wx(this.x+d.x),this.y+d.y,this.mode,this.eat))va.push(i);}
    if(!va.length)return this.dir;
    // Get target
    const tgt=this.target(p);
    // A* pathfinding ‚Äî primary decision maker
    let aa=null;
    if(diff.astar){
      const cf=this.fr?null:this.costFn(p.x,p.y,p.dir);
      const pd=astar(this.x,this.y,tgt.x,tgt.y,cf);
      if(pd)for(let i=0;i<4;i++)if(DIRS[i].x===pd.x&&DIRS[i].y===pd.y&&va.includes(i)){aa=i;break;}
    }
    // Greedy fallback if A* fails
    if(aa===null){let bd=1e9;for(const a of va){const d=DIRS[a],nx=wx(this.x+d.x),ny=this.y+d.y,dd=Math.abs(nx-tgt.x)+Math.abs(ny-tgt.y);if(dd<bd){bd=dd;aa=a;}}}
    // Q-learning: record and learn, but only override A* if very confident
    const st=this.ql.enc(this,p),dist=Math.abs(this.x-p.x)+Math.abs(this.y-p.y);
    let rw=-.1;if(!this.fr)rw+=(this.pdist-dist)*2;else rw+=(dist-this.pdist)*2;
    this.ql.upd(rw,st,va);this.pdist=dist;
    const qa=this.ql.pick(st,va);
    const qConf=this.ql.gq(st,qa)-(aa!==null?this.ql.gq(st,aa):0);
    const trained=this.ql.nu>1000;
    // Only use Q-learning if it's very confident AND well-trained
    const ch=(trained&&qConf>3)?qa:aa;
    this.ql.ls=st;this.ql.la=ch;return DIRS[ch];
  }
  step(p){
    // House release timer runs every frame, not gated by speed
    if(this.mode==='house'){this.rt--;if(this.rt<=0){this.mode=isScat?'scatter':'chase';this.x=14;this.y=11;this.dir={x:-1,y:0};this.mp=0;}return;}
    const sm=this.fr?.45:this.eat?1.6:1;this.mp+=this.spd*sm;if(this.mp<1)return;this.mp=0;
    // Decide direction BEFORE moving (prevents ghosts drifting off-map)
    const a=this.act(p);if(a)this.dir=a;
    // Validate move target before committing
    const nx=wx(this.x+this.dir.x),ny=this.y+this.dir.y;
    if(ny>=0&&ny<R&&gok(nx,ny,this.mode,this.eat)){this.x=nx;this.y=ny;}
    if(this.eat&&Math.abs(this.x-14)<=1&&Math.abs(this.y-14)<=1){this.eat=false;this.fr=false;this.mode='chase';this.x=14;this.y=11;this.dir={x:1,y:0};this.spd=diff.gSpd;}
  }
}
let ghosts=GN.map((n,i)=>new Ghost(n,i));
function resetGhosts(){ghosts.forEach(g=>g.reset());}

// ==== COOP ====
function assignRoles(){if(!diff.coop)return;const a=ghosts.filter(g=>g.mode!=='house'&&!g.eat&&!g.fr);['chase','intercept','patrol','flank'].forEach((r,i)=>{if(a[i])a[i].role=r;});}

// ==== COLLISION ====
function collide(){
  for(const g of ghosts){
    if(g.mode==='house'||g.eat)continue;
    if(g.x===pac.x&&g.y===pac.y){
      if(g.fr){g.ql.term(-80);g.eat=true;g.fr=false;score+=200;diff.kill();sndEatGhost();}
      else{
        ghosts.forEach(ga=>{if(ga.mode!=='house')ga.ql.term(100);});
        lives--;updateUI();diff.die();ghosts.forEach(ga=>ga.ql.save());sndDeath();
        if(lives<=0){gs='dying';if(score>hi){hi=score;localStorage.setItem('pac4_hi',hi);}setTimeout(()=>{gs='gameover';updateUI();showOv('GAME OVER','PRESS ENTER TO RETRY');},1000);}
        else{gs='dying';setTimeout(()=>{const qb=ghosts.map(g2=>g2.ql);resetPac();resetGhosts();ghosts.forEach((g2,i)=>{g2.ql=qb[i];g2.pdist=0;});scIdx=0;scT=0;isScat=true;gs='ready';readyT=90;document.getElementById('ready-text').style.display='block';},800);}
        return true;
      }
    }
  }return false;
}

// ==== INPUT ====
let inQ=[];
let activeDir=null; // currently held d-pad direction (for mobile)
function setDir(dx,dy){inQ=[{x:dx,y:dy}];}
document.addEventListener('keydown',e=>{ensureAudio();
  if(gs==='menu'||gs==='gameover'||gs==='win'){if(e.key==='Enter'||e.key===' '){aiMode=true;startGame();e.preventDefault();return;}}
  let d=null;
  switch(e.key){case'ArrowUp':case'w':case'W':d={x:0,y:-1};break;case'ArrowDown':case's':case'S':d={x:0,y:1};break;case'ArrowLeft':case'a':case'A':d={x:-1,y:0};break;case'ArrowRight':case'd':case'D':d={x:1,y:0};break;default:return;}
  e.preventDefault();
  inQ=[d];
});
document.getElementById('game-container').addEventListener('touchend',e=>{ensureAudio();});
document.querySelectorAll('.diff-btn').forEach(b=>{b.addEventListener('click',e=>{e.stopPropagation();document.querySelectorAll('.diff-btn').forEach(b2=>b2.classList.remove('selected'));b.classList.add('selected');selDiff=b.dataset.diff;document.getElementById('diff-desc').textContent=PRE[selDiff].desc;});
b.addEventListener('touchend',e=>{e.stopPropagation();e.preventDefault();document.querySelectorAll('.diff-btn').forEach(b2=>b2.classList.remove('selected'));b.classList.add('selected');selDiff=b.dataset.diff;document.getElementById('diff-desc').textContent=PRE[selDiff].desc;});});

// D-pad: touchstart sets direction continuously, touchend clears
const dpadMap={
  'btn-up':{x:0,y:-1},'btn-down':{x:0,y:1},
  'btn-left':{x:-1,y:0},'btn-right':{x:1,y:0}
};
Object.entries(dpadMap).forEach(([id,d])=>{
  const el=document.getElementById(id);
  let touched=false;
  el.addEventListener('touchstart',e=>{
    e.preventDefault();e.stopPropagation();
    ensureAudio();touched=true;
    activeDir={...d}; // hold this direction
    inQ=[d];
  },{passive:false});
  el.addEventListener('touchend',e=>{
    e.preventDefault();e.stopPropagation();
    // Only clear if this was the active direction
    if(activeDir&&activeDir.x===d.x&&activeDir.y===d.y)activeDir=null;
  },{passive:false});
  el.addEventListener('touchcancel',e=>{
    if(activeDir&&activeDir.x===d.x&&activeDir.y===d.y)activeDir=null;
  });
  el.addEventListener('click',e=>{
    if(touched){touched=false;return;}
    ensureAudio();inQ=[d];
  });
});

// ==== GAME MGT ====
function showOv(t,h){const o=document.getElementById('overlay');o.classList.remove('hidden');o.querySelector('h1').textContent=t;document.getElementById('start-watch').textContent=h.includes('NEXT')?'ü§ñ NEXT LEVEL':'ü§ñ WATCH AI';document.getElementById('diff-select').style.display='block';}

// Prevent double-fire from touch+click
let startLock=false;
function doStart(ai){
  if(startLock)return;startLock=true;setTimeout(()=>startLock=false,300);
  ensureAudio();aiMode=true;startGame();
}
document.getElementById('start-watch').addEventListener('click',e=>{e.stopPropagation();doStart(true);});
document.getElementById('start-watch').addEventListener('touchend',e=>{e.preventDefault();e.stopPropagation();doStart(true);},{passive:false});
function startGame(){
  const p=PRE[selDiff];score=0;lives=p.lives;level=1;
  initMap();resetPac();
  // Clear stale Q-tables to prevent ghosts from having bad learned habits
  ghosts.forEach(g=>{try{localStorage.removeItem(`pq4_${g.nm}`);}catch(e){}});
  const qb=ghosts.map(g=>new QL(g.nm)); // fresh Q-brains
  resetGhosts();ghosts.forEach((g,i)=>{g.ql=qb[i];g.spd=p.gSpd;g.ql.eps=Math.max(g.ql.me,p.qEps);});
  // Set difficulty from preset ‚Äî don't let upd() override speeds
  diff.gSpd=p.gSpd;diff.frightD=p.frightD;diff.astar=p.astar;diff.coop=p.coop;diff.pred=p.pred;diff.reset();diff.level=p.startLvl;
  // Force badge to match selected preset
  const b=document.getElementById('difficulty-badge');
  if(selDiff==='easy'){b.textContent='EASY';b.style.background='#0f0';b.style.color='#000';}
  else if(selDiff==='medium'){b.textContent='MEDIUM';b.style.background='#FFD700';b.style.color='#000';}
  else{b.textContent='HARD';b.style.background='#f44';b.style.color='#fff';}
  // Ensure ghost speed is from preset (not from adaptive formula)
  ghosts.forEach(g=>{g.spd=p.gSpd;});
  // Always start in chase ‚Äî ghosts pursue immediately
  scIdx=0;scT=0;isScat=false;pm.reset();
  document.getElementById('overlay').classList.add('hidden');document.getElementById('ai-panel').classList.add('active');document.getElementById('difficulty-badge').style.display='block';
  document.getElementById('ai-mode-badge').style.display=aiMode?'block':'none';
  gs='ready';readyT=90;document.getElementById('ready-text').style.display='block';updateUI();sndStart();
}

// ==== MAIN UPDATE ====
let lpp={x:-1,y:-1};
function update(){
  if(gs==='ready'){readyT--;if(readyT<=0){gs='playing';document.getElementById('ready-text').style.display='none';}return;}
  if(gs==='dying')return;
  if(gs!=='playing')return;
  af++;diff.surv++;
  // AI autopilot or human input
  if(aiMode){
    // AI thinks every time pac is about to move (at tile boundaries)
    if(pac.tick+1>=PAC_TICK||pac.dir.x===0&&pac.dir.y===0){
      const aiDir=pacAI.think();
      if(aiDir)pacInput(aiDir);
    }
    // Human can take over anytime by pressing a direction
    if(inQ.length){aiMode=false;pacInput(inQ[0]);inQ=[];document.getElementById('ai-mode-badge').style.display='none';}
  } else {
    if(inQ.length){pacInput(inQ[0]);inQ=[];}
    if(activeDir&&!inQ.length)pacInput(activeDir);
  }
  const moved=pacStep();
  if(moved){
    if(pac.x!==lpp.x||pac.y!==lpp.y){pm.rec(pac.x,pac.y,pac.dir);lpp={x:pac.x,y:pac.y};}
    // EAT FIRST ‚Äî pellets must frighten ghosts before collision check
    const tile=map[pac.y]?.[pac.x];
    if(tile===2){map[pac.y][pac.x]=0;score+=10;dotsEaten++;sndChomp();}
    else if(tile===3){map[pac.y][pac.x]=0;score+=50;dotsEaten++;frightT=diff.frightD;ghosts.forEach(g=>{if(g.mode!=='house'&&!g.eat){g.fr=true;g.dir={x:-g.dir.x,y:-g.dir.y};}});sndPower();}
    // NOW check collisions (ghosts are frightened if we just ate a pellet)
    if(collide())return;
    if(dotsEaten>=totalDots){gs='win';sndWin();ghosts.forEach(g=>g.ql.save());showOv('LEVEL CLEAR!','PRESS ENTER FOR NEXT LEVEL');setTimeout(()=>{const qb=ghosts.map(g=>g.ql);level++;initMap();resetPac();resetGhosts();ghosts.forEach((g,i)=>{g.ql=qb[i];g.pdist=0;});scIdx=0;scT=0;isScat=true;dotsEaten=0;document.getElementById('overlay').classList.add('hidden');gs='ready';readyT=90;document.getElementById('ready-text').style.display='block';},2500);return;}
  }
  if(af%3===0){pac.ma+=pac.mo?6:-6;if(pac.ma>=45)pac.mo=false;if(pac.ma<=2)pac.mo=true;}
  if(frightT>0){frightT--;if(frightT<=0)ghosts.forEach(g=>{g.fr=false;});}
  scT++;const ST=[180,180,120,120],CT2=[1800,1800,2400,Infinity];const th=isScat?ST[Math.min(scIdx,3)]:CT2[Math.min(scIdx,3)];
  if(scT>=th&&th!==Infinity){scT=0;isScat=!isScat;if(isScat)scIdx++;ghosts.forEach(g=>{if(g.mode!=='house'&&!g.fr&&!g.eat){g.mode=isScat?'scatter':'chase';g.dir={x:-g.dir.x,y:-g.dir.y};}});}
  if(af%30===0)assignRoles();
  ghosts.forEach(g=>g.step(pac));
  if(collide())return;
  if(af%20===0)updPanel();
  updateUI();
}

// ==== UI ====
function updateUI(){document.getElementById('score').textContent=score;document.getElementById('high-score').textContent=Math.max(score,hi);let s='';for(let i=0;i<lives;i++)s+='‚ù§ ';document.getElementById('lives-display').textContent=lives>0?s.trim():'üíÄ';}
function updPanel(){
  document.getElementById('ai-diff').textContent=selDiff.toUpperCase()+' ('+diff.level.toFixed(1)+')';document.getElementById('ai-diff').className='ai-value'+(selDiff==='hard'?' danger':selDiff==='medium'?' warn':'');
  document.getElementById('ai-patterns').textContent=pm.moves.length+' moves';
  document.getElementById('ai-astar').textContent=diff.astar?'WEIGHTED A*':'GREEDY';
  const tq=ghosts.reduce((s2,g)=>s2+g.ql.stats().st,0),ae=ghosts.reduce((s2,g)=>s2+g.ql.eps,0)/4;
  document.getElementById('ai-qlearn').textContent=`${tq} states, Œµ=${ae.toFixed(2)}`;
  ghosts.forEach(g=>{const el=document.getElementById('role-'+g.nm);const rn=(g.role||g.pers).toUpperCase().replace(/_/g,' ');const st2=g.fr?'‚ö°SCARED':g.eat?'üëÄEATEN':g.mode==='house'?'üè†HOME':rn;el.textContent=`${g.nm.toUpperCase()}: ${st2}`;});
}

// ==== DRAW ====
function draw(){
  ctx.fillStyle='#000';ctx.fillRect(0,0,canvas.width,canvas.height);
  for(let r=0;r<R;r++)for(let c=0;c<C;c++){const t=map[r][c];if(t===1)drawW(c,r);else if(t===2){ctx.fillStyle='#FFB8AE';ctx.beginPath();ctx.arc(c*T+T/2,r*T+T/2,2,0,Math.PI*2);ctx.fill();}else if(t===3&&Math.floor(af/15)%2===0){ctx.fillStyle='#FFB8AE';ctx.beginPath();ctx.arc(c*T+T/2,r*T+T/2,6,0,Math.PI*2);ctx.fill();}else if(t===4){ctx.fillStyle='#FFB8FF';ctx.fillRect(c*T,r*T+T/2-2,T,4);}}
  if(diff.coop&&pm.pt&&gs==='playing'){ctx.strokeStyle='rgba(255,34,102,.3)';ctx.lineWidth=1;ctx.setLineDash([3,3]);ctx.beginPath();ctx.arc(pm.pt.x*T+T/2,pm.pt.y*T+T/2,T/2+2,0,Math.PI*2);ctx.stroke();ctx.setLineDash([]);}
  if(gs==='playing'||gs==='ready'||gs==='dying'){const px=pac.x*T+T/2,py=pac.y*T+T/2,pr=T/2-1,mr=pac.ma*Math.PI/180;let a=0;if(pac.dir.x===1)a=0;else if(pac.dir.x===-1)a=Math.PI;else if(pac.dir.y===-1)a=-Math.PI/2;else if(pac.dir.y===1)a=Math.PI/2;ctx.fillStyle='#FFFF00';ctx.beginPath();ctx.moveTo(px,py);ctx.arc(px,py,pr,a+mr,a+Math.PI*2-mr);ctx.closePath();ctx.fill();}
  ghosts.forEach(g=>{const gx=g.x*T+T/2,gy=g.y*T+T/2,gr=T/2-1;if(g.eat){drawE(gx,gy,g.dir);return;}ctx.fillStyle=g.fr?(frightT<120&&Math.floor(af/10)%2?'#FFF':'#00F'):g.col;ctx.beginPath();ctx.arc(gx,gy-2,gr,Math.PI,0);ctx.lineTo(gx+gr,gy+gr);const wv=Math.sin(af*.3)*2,sw=gr*2/3;for(let s=0;s<3;s++){const sx=gx+gr-s*sw,sy=gy+gr;ctx.lineTo(sx-sw/2,sy-4+wv*(s%2?-1:1));ctx.lineTo(sx-sw,sy);}ctx.closePath();ctx.fill();
  if(g.role&&diff.coop&&!g.fr){const rc={chase:'#f44',intercept:'#f80',patrol:'#4f4',flank:'#48f',guard_pellet:'#ff0'};ctx.strokeStyle=rc[g.role]||'#fff3';ctx.lineWidth=1.5;ctx.beginPath();ctx.arc(gx,gy-1,gr+3,0,Math.PI*2);ctx.stroke();}
  if(g.fr){ctx.fillStyle='#fff';ctx.beginPath();ctx.arc(gx-3,gy-3,2,0,Math.PI*2);ctx.arc(gx+3,gy-3,2,0,Math.PI*2);ctx.fill();ctx.strokeStyle='#fff';ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(gx-5,gy+3);for(let m=0;m<5;m++)ctx.lineTo(gx-5+m*2.5,gy+3+(m%2?-2:0));ctx.stroke();}else drawE(gx,gy,g.dir);});
}
function drawW(x,y){const s=T,t2=y>0&&map[y-1][x]===1,b=y<R-1&&map[y+1][x]===1,l=x>0&&map[y][x-1]===1,r=x<C-1&&map[y][x+1]===1;ctx.strokeStyle='#44F';ctx.lineWidth=2;const px=x*s,py=y*s,cx2=px+s/2,cy=py+s/2;if(!t2){ctx.beginPath();ctx.moveTo(px+2,cy);ctx.lineTo(px+s-2,cy);ctx.stroke();}if(!b){ctx.beginPath();ctx.moveTo(px+2,cy);ctx.lineTo(px+s-2,cy);ctx.stroke();}if(!l){ctx.beginPath();ctx.moveTo(cx2,py+2);ctx.lineTo(cx2,py+s-2);ctx.stroke();}if(!r){ctx.beginPath();ctx.moveTo(cx2,py+2);ctx.lineTo(cx2,py+s-2);ctx.stroke();}if(t2){ctx.beginPath();ctx.moveTo(cx2,py);ctx.lineTo(cx2,cy);ctx.stroke();}if(b){ctx.beginPath();ctx.moveTo(cx2,py+s);ctx.lineTo(cx2,cy);ctx.stroke();}if(l){ctx.beginPath();ctx.moveTo(px,cy);ctx.lineTo(cx2,cy);ctx.stroke();}if(r){ctx.beginPath();ctx.moveTo(px+s,cy);ctx.lineTo(cx2,cy);ctx.stroke();}}
function drawE(gx,gy,d){ctx.fillStyle='#fff';ctx.beginPath();ctx.ellipse(gx-4,gy-3,4,5,0,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.ellipse(gx+4,gy-3,4,5,0,0,Math.PI*2);ctx.fill();ctx.fillStyle='#2121DE';ctx.beginPath();ctx.arc(gx-4+d.x*2,gy-3+d.y*2,2,0,Math.PI*2);ctx.fill();ctx.beginPath();ctx.arc(gx+4+d.x*2,gy-3+d.y*2,2,0,Math.PI*2);ctx.fill();}

function loop(){update();draw();requestAnimationFrame(loop);}
initMap();diff.upd();updateUI();loop();
</script>
</body>
</html>
